[{"path":"/articles/zmisc.html","id":"vector-lookups-and-safer-sampling","dir":"Articles","previous_headings":"","what":"Vector Lookups and Safer Sampling","title":"zmisc","text":"package contains several utility functions, including functions look vector values lookup table, functions support safer approach vector sampling, sequence generation, aggregation.","code":""},{"path":"/articles/zmisc.html","id":"installation","dir":"Articles","previous_headings":"","what":"Installation","title":"zmisc","text":"can install released version zmisc CRAN : can install development version zmisc GitHub :","code":"install.packages(\"zmisc\") remotes::install_github(\"torfason/zmisc\")"},{"path":"/articles/zmisc.html","id":"usage","dir":"Articles","previous_headings":"","what":"Usage","title":"zmisc","text":"order use package, generally want attach first:","code":"library(zmisc)"},{"path":"/articles/zmisc.html","id":"quick-and-easy-value-lookups","dir":"Articles","previous_headings":"","what":"Quick and easy value lookups","title":"zmisc","text":"functions lookup() lookuper() used look values lookup table, can supplied vector, list, data.frame. functions ways similar Excel function VLOOKUP(), designed work smoothly R workflow, particular within pipes.","code":""},{"path":"/articles/zmisc.html","id":"lookup-lookup-values-from-a-lookup-table","dir":"Articles","previous_headings":"Quick and easy value lookups","what":"lookup: Lookup values from a lookup table","title":"zmisc","text":"lookup() function implements lookup certain strings (variable names) lookup table maps keys onto values (variable labels descriptions). Original values returned found lookup table. lookup table can form two-column data.frame, form named vector, form list. table form data.frame, lookup columns named name (key) value (value). lookup table form named vector list, name used key, returned value taken values vector list. names x included result.","code":""},{"path":"/articles/zmisc.html","id":"examples","dir":"Articles","previous_headings":"Quick and easy value lookups > lookup: Lookup values from a lookup table","what":"Examples","title":"zmisc","text":"","code":"fruit_lookup_vector <- c(a=\"Apple\", b=\"Banana\", c=\"Cherry\") lookup(letters[1:5], fruit_lookup_vector)  mtcars_lookup_data_frame <- data.frame(   name = c(\"mpg\", \"hp\", \"wt\"),   value = c(\"Miles/(US) gallon\", \"Gross horsepower\", \"Weight (1000 lbs)\")) lookup(names(mtcars), mtcars_lookup_data_frame)"},{"path":"/articles/zmisc.html","id":"lookuper-construct-lookup-function-based-on-a-specific-lookup-table","dir":"Articles","previous_headings":"Quick and easy value lookups","what":"lookuper: Construct lookup function based on a specific lookup table","title":"zmisc","text":"lookuper() function returns function equivalent lookup() function, except instead taking lookup table argument, lookup table embedded function . can useful, particular using lookup function argument functions expect function maps character->character offer good way pass additional arguments function.","code":""},{"path":"/articles/zmisc.html","id":"examples-1","dir":"Articles","previous_headings":"Quick and easy value lookups > lookuper: Construct lookup function based on a specific lookup table","what":"Examples","title":"zmisc","text":"","code":"lookup_fruits <- lookuper(list(a=\"Apple\", b=\"Banana\", c=\"Cherry\")) lookup_fruits(letters[1:5])"},{"path":"/articles/zmisc.html","id":"safer-sampling-sequencing-and-aggregation","dir":"Articles","previous_headings":"","what":"Safer sampling, sequencing and aggregation","title":"zmisc","text":"functions zample(), zeq(), zingle() intended make code less likely break mysterious ways encounter unexpected boundary conditions. zample() zeq() almost identical sample() seq() functions, bit safer.","code":""},{"path":"/articles/zmisc.html","id":"zample-sample-from-a-vector-in-a-safe-way","dir":"Articles","previous_headings":"Safer sampling, sequencing and aggregation","what":"zample: Sample from a vector in a safe way","title":"zmisc","text":"zample() function duplicates functionality sample(), exception attempt (sometimes dangerous) user-friendliness switching interpretation first element number length vector 1. zample() always treats first argument vector containing elements sampled, code wonâ€™t break unexpected ways input vector happens length 1.","code":""},{"path":"/articles/zmisc.html","id":"examples-2","dir":"Articles","previous_headings":"Safer sampling, sequencing and aggregation > zample: Sample from a vector in a safe way","what":"Examples","title":"zmisc","text":"","code":"# For vectors of length 2 or more, zample() and sample() are identical set.seed(42); zample(7:11) set.seed(42); sample(7:11)  # For vectors of length 1, zample() will still sample from the vector, # whereas sample() will \"magically\" switch to interpreting the input # as a number n, and sampling from the vector 1:n. set.seed(42); zample(7) set.seed(42); sample(7)  # The other arguments work in the same way as for sample() set.seed(42); zample(7:11, size=13, replace=TRUE, prob=(5:1)^3) set.seed(42); sample(7:11, size=13, replace=TRUE, prob=(5:1)^3)  # Of course, sampling more than the available elements without # setting replace=TRUE will result in an error set.seed(42); tryCatch(zample(7, size=2), error=zmisc:::wrap_error)"},{"path":"/articles/zmisc.html","id":"zeq-generate-sequence-in-a-safe-way","dir":"Articles","previous_headings":"Safer sampling, sequencing and aggregation","what":"zeq: Generate sequence in a safe way","title":"zmisc","text":"zeq() function creates increasing integer sequence, differs standard one silently generate decreasing sequence second argument smaller first. second argument one smaller first generate empty sequence, difference greater, function throw error.","code":""},{"path":"/articles/zmisc.html","id":"examples-3","dir":"Articles","previous_headings":"Safer sampling, sequencing and aggregation > zeq: Generate sequence in a safe way","what":"Examples","title":"zmisc","text":"","code":"# For increasing sequences, zeq() and seq() are identical zeq(11,15) zeq(11,11)  # If second argument equals first-1, an empty sequence is returned zeq(11,10)  # If second argument is less than first-1, the function throws an error tryCatch(zeq(11,9), error=zmisc:::wrap_error)"},{"path":"/articles/zmisc.html","id":"zingle-return-the-single-unique-value-found-in-a-vector","dir":"Articles","previous_headings":"Safer sampling, sequencing and aggregation","what":"zingle: Return the single (unique) value found in a vector","title":"zmisc","text":"zingle() function returns first element vector, elements identical first one (vector zingle value). elements identical, throws error. vector must contain least one non-NA value, function errors well. especially useful aggregations, values given group identical, want make sure.","code":""},{"path":"/articles/zmisc.html","id":"examples-4","dir":"Articles","previous_headings":"Safer sampling, sequencing and aggregation > zingle: Return the single (unique) value found in a vector","what":"Examples","title":"zmisc","text":"","code":"# For increasing sequences, zeq() and seq() are identical zeq(11,15) zeq(11,11)  # If second argument equals first-1, an empty sequence is returned zeq(11,10)  # If second argument is less than first-1, the function throws an error tryCatch(zeq(11,9), error=zmisc:::wrap_error)"},{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Magnus Thor Torfason. Maintainer.","code":""},{"path":"/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Torfason MT (2022). zmisc: Vector Lookups Safer Sampling. R package version 0.2.1.","code":"@Manual{,   title = {zmisc: Vector Lookups and Safer Sampling},   author = {Magnus Thor Torfason},   year = {2022},   note = {R package version 0.2.1}, }"},{"path":[]},{"path":"/index.html","id":"vector-lookups-and-safer-sampling","dir":"","previous_headings":"","what":"Vector Lookups and Safer Sampling","title":"Vector Lookups and Safer Sampling","text":"package contains several utility functions, including functions look vector values lookup table, functions support safer approach vector sampling, sequence generation, aggregation.","code":""},{"path":"/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Vector Lookups and Safer Sampling","text":"can install released version zmisc CRAN : can install development version zmisc GitHub :","code":"install.packages(\"zmisc\") remotes::install_github(\"torfason/zmisc\")"},{"path":"/index.html","id":"usage","dir":"","previous_headings":"","what":"Usage","title":"Vector Lookups and Safer Sampling","text":"order use package, generally want attach first:","code":"library(zmisc)"},{"path":"/index.html","id":"quick-and-easy-value-lookups","dir":"","previous_headings":"","what":"Quick and easy value lookups","title":"Vector Lookups and Safer Sampling","text":"functions lookup() lookuper() used look values lookup table, can supplied vector, list, data.frame. functions ways similar Excel function VLOOKUP(), designed work smoothly R workflow, particular within pipes.","code":""},{"path":"/index.html","id":"lookup-lookup-values-from-a-lookup-table","dir":"","previous_headings":"Quick and easy value lookups","what":"lookup: Lookup values from a lookup table","title":"Vector Lookups and Safer Sampling","text":"lookup() function implements lookup certain strings (variable names) lookup table maps keys onto values (variable labels descriptions). Original values returned found lookup table. lookup table can form two-column data.frame, form named vector, form list. table form data.frame, lookup columns named name (key) value (value). lookup table form named vector list, name used key, returned value taken values vector list. names x included result.","code":""},{"path":"/index.html","id":"examples","dir":"","previous_headings":"Quick and easy value lookups > lookup: Lookup values from a lookup table","what":"Examples","title":"Vector Lookups and Safer Sampling","text":"","code":"fruit_lookup_vector <- c(a=\"Apple\", b=\"Banana\", c=\"Cherry\") lookup(letters[1:5], fruit_lookup_vector)  mtcars_lookup_data_frame <- data.frame(   name = c(\"mpg\", \"hp\", \"wt\"),   value = c(\"Miles/(US) gallon\", \"Gross horsepower\", \"Weight (1000 lbs)\")) lookup(names(mtcars), mtcars_lookup_data_frame)"},{"path":"/index.html","id":"lookuper-construct-lookup-function-based-on-a-specific-lookup-table","dir":"","previous_headings":"Quick and easy value lookups","what":"lookuper: Construct lookup function based on a specific lookup table","title":"Vector Lookups and Safer Sampling","text":"lookuper() function returns function equivalent lookup() function, except instead taking lookup table argument, lookup table embedded function . can useful, particular using lookup function argument functions expect function maps character->character offer good way pass additional arguments function.","code":""},{"path":"/index.html","id":"examples-1","dir":"","previous_headings":"Quick and easy value lookups > lookuper: Construct lookup function based on a specific lookup table","what":"Examples","title":"Vector Lookups and Safer Sampling","text":"","code":"lookup_fruits <- lookuper(list(a=\"Apple\", b=\"Banana\", c=\"Cherry\")) lookup_fruits(letters[1:5])"},{"path":"/index.html","id":"safer-sampling-sequencing-and-aggregation","dir":"","previous_headings":"","what":"Safer sampling, sequencing and aggregation","title":"Vector Lookups and Safer Sampling","text":"functions zample(), zeq(), zingle() intended make code less likely break mysterious ways encounter unexpected boundary conditions. zample() zeq() almost identical sample() seq() functions, bit safer.","code":""},{"path":"/index.html","id":"zample-sample-from-a-vector-in-a-safe-way","dir":"","previous_headings":"Safer sampling, sequencing and aggregation","what":"zample: Sample from a vector in a safe way","title":"Vector Lookups and Safer Sampling","text":"zample() function duplicates functionality sample(), exception attempt (sometimes dangerous) user-friendliness switching interpretation first element number length vector 1. zample() always treats first argument vector containing elements sampled, code wonâ€™t break unexpected ways input vector happens length 1.","code":""},{"path":"/index.html","id":"examples-2","dir":"","previous_headings":"Safer sampling, sequencing and aggregation > zample: Sample from a vector in a safe way","what":"Examples","title":"Vector Lookups and Safer Sampling","text":"","code":"# For vectors of length 2 or more, zample() and sample() are identical set.seed(42); zample(7:11) set.seed(42); sample(7:11)  # For vectors of length 1, zample() will still sample from the vector, # whereas sample() will \"magically\" switch to interpreting the input # as a number n, and sampling from the vector 1:n. set.seed(42); zample(7) set.seed(42); sample(7)  # The other arguments work in the same way as for sample() set.seed(42); zample(7:11, size=13, replace=TRUE, prob=(5:1)^3) set.seed(42); sample(7:11, size=13, replace=TRUE, prob=(5:1)^3)  # Of course, sampling more than the available elements without # setting replace=TRUE will result in an error set.seed(42); tryCatch(zample(7, size=2), error=zmisc:::wrap_error)"},{"path":"/index.html","id":"zeq-generate-sequence-in-a-safe-way","dir":"","previous_headings":"Safer sampling, sequencing and aggregation","what":"zeq: Generate sequence in a safe way","title":"Vector Lookups and Safer Sampling","text":"zeq() function creates increasing integer sequence, differs standard one silently generate decreasing sequence second argument smaller first. second argument one smaller first generate empty sequence, difference greater, function throw error.","code":""},{"path":"/index.html","id":"examples-3","dir":"","previous_headings":"Safer sampling, sequencing and aggregation > zeq: Generate sequence in a safe way","what":"Examples","title":"Vector Lookups and Safer Sampling","text":"","code":"# For increasing sequences, zeq() and seq() are identical zeq(11,15) zeq(11,11)  # If second argument equals first-1, an empty sequence is returned zeq(11,10)  # If second argument is less than first-1, the function throws an error tryCatch(zeq(11,9), error=zmisc:::wrap_error)"},{"path":"/index.html","id":"zingle-return-the-single-unique-value-found-in-a-vector","dir":"","previous_headings":"Safer sampling, sequencing and aggregation","what":"zingle: Return the single (unique) value found in a vector","title":"Vector Lookups and Safer Sampling","text":"zingle() function returns first element vector, elements identical first one (vector zingle value). elements identical, throws error. vector must contain least one non-NA value, function errors well. especially useful aggregations, values given group identical, want make sure.","code":""},{"path":"/index.html","id":"examples-4","dir":"","previous_headings":"Safer sampling, sequencing and aggregation > zingle: Return the single (unique) value found in a vector","what":"Examples","title":"Vector Lookups and Safer Sampling","text":"","code":"# For increasing sequences, zeq() and seq() are identical zeq(11,15) zeq(11,11)  # If second argument equals first-1, an empty sequence is returned zeq(11,10)  # If second argument is less than first-1, the function throws an error tryCatch(zeq(11,9), error=zmisc:::wrap_error)"},{"path":"/reference/lookup.html","id":null,"dir":"Reference","previous_headings":"","what":"Lookup values from a lookup table â€” lookup","title":"Lookup values from a lookup table â€” lookup","text":"lookup() function implements lookup certain strings (variable names) lookup table maps keys onto values (variable labels descriptions). Original values returned found lookup table. lookup table can form two-column data.frame, form named vector, form list. table form data.frame, lookup columns named name (key) value (value). lookup table form named vector list, name used key, returned value taken values vector list. names x included result.","code":""},{"path":"/reference/lookup.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Lookup values from a lookup table â€” lookup","text":"","code":"lookup(x, lookup_table)"},{"path":"/reference/lookup.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Lookup values from a lookup table â€” lookup","text":"x string vector whose elements shall looked lookup_table lookup table use.","code":""},{"path":"/reference/lookup.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Lookup values from a lookup table â€” lookup","text":"string vector based x, values replaced lookup values lookup_table. values found lookup table returned unchanged.","code":""},{"path":"/reference/lookup.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Lookup values from a lookup table â€” lookup","text":"","code":"fruit_lookup_vector <- c(a=\"Apple\", b=\"Banana\", c=\"Cherry\") lookup(letters[1:5], fruit_lookup_vector) #> [1] \"Apple\"  \"Banana\" \"Cherry\" \"d\"      \"e\"       mtcars_lookup_data_frame <- data.frame(   name = c(\"mpg\", \"hp\", \"wt\"),   value = c(\"Miles/(US) gallon\", \"Gross horsepower\", \"Weight (1000 lbs)\")) lookup(names(mtcars), mtcars_lookup_data_frame) #>  [1] \"Miles/(US) gallon\" \"cyl\"               \"disp\"              #>  [4] \"Gross horsepower\"  \"drat\"              \"Weight (1000 lbs)\" #>  [7] \"qsec\"              \"vs\"                \"am\"                #> [10] \"gear\"              \"carb\""},{"path":"/reference/lookuper.html","id":null,"dir":"Reference","previous_headings":"","what":"Construct lookup function based on a specific lookup table â€” lookuper","title":"Construct lookup function based on a specific lookup table â€” lookuper","text":"lookuper() function returns function equivalent lookup() function, except instead taking lookup table argument, lookup table embedded function . can useful, particular using lookup function argument functions expect function maps character->character offer good way pass additional arguments function.","code":""},{"path":"/reference/lookuper.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Construct lookup function based on a specific lookup table â€” lookuper","text":"","code":"lookuper(lookup_table)"},{"path":"/reference/lookuper.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Construct lookup function based on a specific lookup table â€” lookuper","text":"lookup_table lookup table used underlying lookup table returned function.","code":""},{"path":"/reference/lookuper.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Construct lookup function based on a specific lookup table â€” lookuper","text":"function takes character vectors argument x, returns either corresponding values underlying lookup table, original values x elements found lookup table.","code":""},{"path":"/reference/lookuper.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Construct lookup function based on a specific lookup table â€” lookuper","text":"","code":"lookup_fruits <- lookuper(list(a=\"Apple\", b=\"Banana\", c=\"Cherry\")) lookup_fruits(letters[1:5]) #> [1] \"Apple\"  \"Banana\" \"Cherry\" \"d\"      \"e\""},{"path":"/reference/standardize_lookup_table.html","id":null,"dir":"Reference","previous_headings":"","what":"Helper function to standardize the lookup_table. â€” standardize_lookup_table","title":"Helper function to standardize the lookup_table. â€” standardize_lookup_table","text":"Preprocessing lookup table convert list can take time, possible, want . Therefore offload helper function","code":""},{"path":"/reference/standardize_lookup_table.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Helper function to standardize the lookup_table. â€” standardize_lookup_table","text":"","code":"standardize_lookup_table(lookup_table)"},{"path":"/reference/standardize_lookup_table.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Helper function to standardize the lookup_table. â€” standardize_lookup_table","text":"lookup_table unstandardized lookup table (must still one formats specified lookup() function).","code":""},{"path":"/reference/standardize_lookup_table.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Helper function to standardize the lookup_table. â€” standardize_lookup_table","text":"lookup table list.","code":""},{"path":"/reference/wrap_error.html","id":null,"dir":"Reference","previous_headings":"","what":"Utility function to output an error â€” wrap_error","title":"Utility function to output an error â€” wrap_error","text":"function used output errors examples tidy manner.","code":""},{"path":"/reference/wrap_error.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Utility function to output an error â€” wrap_error","text":"","code":"wrap_error(e, wrap = 50)"},{"path":"/reference/wrap_error.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Utility function to output an error â€” wrap_error","text":"e error wrap wrap many characters wrapping","code":""},{"path":"/reference/wrap_error.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Utility function to output an error â€” wrap_error","text":"error returned invisibly","code":""},{"path":"/reference/zample.html","id":null,"dir":"Reference","previous_headings":"","what":"Sample from a vector in a safe way â€” zample","title":"Sample from a vector in a safe way â€” zample","text":"zample() function duplicates functionality sample(), exception attempt (sometimes dangerous) user-friendliness switching interpretation first element number length vector 1. zample() always treats first argument vector containing elements sampled, code break unexpected ways input vector happens length 1.","code":""},{"path":"/reference/zample.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sample from a vector in a safe way â€” zample","text":"","code":"zample(x, size = length(x), replace = FALSE, prob = NULL)"},{"path":"/reference/zample.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sample from a vector in a safe way â€” zample","text":"x vector sample size number elements sample x (defaults length(x)) replace elements replaced sampling (defaults false) prob vector probability weights (defaults equal probabilities)","code":""},{"path":"/reference/zample.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Sample from a vector in a safe way â€” zample","text":"resulting sample","code":""},{"path":"/reference/zample.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Sample from a vector in a safe way â€” zample","text":"really want sample interval 1 n, can use sample(n) sample.int(n) (make sure pass vectors length one functions).","code":""},{"path":"/reference/zample.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Sample from a vector in a safe way â€” zample","text":"","code":"# For vectors of length 2 or more, zample() and sample() are identical set.seed(42); zample(7:11) #> [1]  7 11 10  9  8 set.seed(42); sample(7:11) #> [1]  7 11 10  9  8  # For vectors of length 1, zample() will still sample from the vector, # whereas sample() will \"magically\" switch to interpreting the input # as a number n, and sampling from the vector 1:n. set.seed(42); zample(7) #> [1] 7 set.seed(42); sample(7) #> [1] 1 5 7 6 2 3 4  # The other arguments work in the same way as for sample() set.seed(42); zample(7:11, size=13, replace=TRUE, prob=(5:1)^3) #>  [1] 9 9 7 8 8 7 8 7 8 8 7 8 9 set.seed(42); sample(7:11, size=13, replace=TRUE, prob=(5:1)^3) #>  [1] 9 9 7 8 8 7 8 7 8 8 7 8 9  # Of course, sampling more than the available elements without # setting replace=TRUE will result in an error set.seed(42); tryCatch(zample(7, size=2), error=zmisc:::wrap_error) #> #E> cannot take a sample larger than the population #> #E> when 'replace = FALSE'"},{"path":"/reference/zeq.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate sequence in a safe way â€” zeq","title":"Generate sequence in a safe way â€” zeq","text":"zeq() function creates increasing integer sequence, differs standard one silently generate decreasing sequence second argument smaller first. second argument one smaller first generate empty sequence, difference greater, function throw error.","code":""},{"path":"/reference/zeq.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate sequence in a safe way â€” zeq","text":"","code":"zeq(from, to)"},{"path":"/reference/zeq.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate sequence in a safe way â€” zeq","text":"lower bound sequence higher bound sequence","code":""},{"path":"/reference/zeq.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate sequence in a safe way â€” zeq","text":"sequence ranging ","code":""},{"path":"/reference/zeq.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate sequence in a safe way â€” zeq","text":"","code":"# For increasing sequences, zeq() and seq() are identical zeq(11,15) #> [1] 11 12 13 14 15 zeq(11,11) #> [1] 11  # If second argument equals first-1, an empty sequence is returned zeq(11,10) #> numeric(0)  # If second argument is less than first-1, the function throws an error tryCatch(zeq(11,9), error=zmisc:::wrap_error) #> #E> to >= from - 1 is not TRUE"},{"path":"/reference/zingle.html","id":null,"dir":"Reference","previous_headings":"","what":"Return the single (unique) value found in a vector â€” zingle","title":"Return the single (unique) value found in a vector â€” zingle","text":"zingle() function returns first element vector, elements identical first one (vector zingle value). elements identical, throws error. vector must contain least one non-NA value, function errors well. especially useful aggregations, values given group identical, want make sure.","code":""},{"path":"/reference/zingle.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Return the single (unique) value found in a vector â€” zingle","text":"","code":"zingle(x, na.rm = FALSE)"},{"path":"/reference/zingle.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Return the single (unique) value found in a vector â€” zingle","text":"x Vector elements identical na.rm NA elements removed prior comparison","code":""},{"path":"/reference/zingle.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Return the single (unique) value found in a vector â€” zingle","text":"zingle element vector","code":""},{"path":"/reference/zingle.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Return the single (unique) value found in a vector â€” zingle","text":"Optionally takes na.rm parameter, similarly sum, mean aggregate functions. TRUE, NA values removed prior comparing elements, function accept input values contain combination single value NA values (least one non-NA value required).","code":""},{"path":"/reference/zingle.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Return the single (unique) value found in a vector â€” zingle","text":"","code":"# If all elements are identical, all is good. # The value of the element is returned. zingle(c(\"Alpha\", \"Alpha\", \"Alpha\")) #> [1] \"Alpha\"  # If any elements differ, an error is thrown tryCatch(zingle(c(\"Alpha\", \"Beta\", \"Alpha\")), error=zmisc:::wrap_error) #> #E> all(x[1] == x) is not TRUE  if (require(\"dplyr\", quietly=TRUE, warn.conflicts=FALSE)) {   d <- tibble::tribble(     ~id, ~name, ~fouls,     1, \"James\", 3,     2, \"Jack\",  2,     1, \"James\", 4   )    # If the data is of the correct format, all is good   d %>%     dplyr::group_by(id) %>%     dplyr::summarise(name=zingle(name), total_fouls=sum(fouls))  } #> # A tibble: 2 Ã— 3 #>      id name  total_fouls #>   <dbl> <chr>       <dbl> #> 1     1 James           7 #> 2     2 Jack            2  if (require(\"dplyr\", quietly=TRUE, warn.conflicts=FALSE)) {   # If a name does not match its ID, we should get an error   d[1,\"name\"] <- \"Jammes\"   tryCatch({     d %>%       dplyr::group_by(id) %>%       dplyr::summarise(name=zingle(name), total_fouls=sum(fouls))   }, error=zmisc:::wrap_error) } #> #E> Problem with `summarise()` column `name`. #> #E> â„¹ `name = zingle(name)`. âœ– #> #E> all(x[1] == x) is not TRUE â„¹ The error #> #E> occurred in group 1: id = 1."},{"path":"/reference/zmisc.html","id":null,"dir":"Reference","previous_headings":"","what":"zmisc: Vector Lookups and Safer Sampling â€” zmisc","title":"zmisc: Vector Lookups and Safer Sampling â€” zmisc","text":"package contains several utility functions, including functions look vector values lookup table, functions support safer approach vector sampling, sequence generation, aggregation. information, see vignette(\"zmisc\").","code":""},{"path":"/news/index.html","id":"zmisc-021","dir":"Changelog","previous_headings":"","what":"zmisc 0.2.1","title":"zmisc 0.2.1","text":"version includes documentation improvements well fixes.","code":""},{"path":"/news/index.html","id":"zmisc-020","dir":"Changelog","previous_headings":"","what":"zmisc 0.2.0","title":"zmisc 0.2.0","text":"version adds two functions, lookup() lookuper(), designed look values lookup table way works smoothly R workflow, particular within pipes.","code":""},{"path":"/news/index.html","id":"zmisc-010","dir":"Changelog","previous_headings":"","what":"zmisc 0.1.0","title":"zmisc 0.1.0","text":"initial version zmisc, includes three functions, zample(), zeq(), zingle(), safer sampling, sequencing subsetting data processing workflow","code":""}]
